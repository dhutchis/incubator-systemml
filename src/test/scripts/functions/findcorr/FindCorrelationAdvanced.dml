
k = as.scalar(read($1))
n = as.scalar(read($2))
c = as.scalar(read($3))
alpha = as.scalar(read($4))
t = as.scalar(read($5))

n13 = as.integer(n^(1.0/3.0))
n23 = as.integer(n^(2.0/3.0))
alphan23 = as.integer(alpha*n^(2.0/3.0))
logn = as.integer(log(n,2))
clogn = as.integer(c*log(n,2))

# random matrix of -1 and 1
# todo optimize to 0 and 1
#AR = rand(rows=clogn, cols=n, min=0, max=1, pdf="uniform", sparsity=1.0)
#A = -1 * (AR <= 0.5) + (AR > 0.5)
A = read($6)    # clogn x n
Ar = nrow(A)
Ac = ncol(A)
print("A is "+Ar+" by "+Ac)

# Create S of size n x n23
S = matrix(0, rows=n, cols=n23)
for (i in 1:n23) {
	S[(i-1)*n13+1:i*n13, i] = matrix(1, rows=n13, cols=1)
}

ok = FALSE
failCount = -1
Y = matrix(0, rows=n13, cols=n13)
while (!ok) {
    failCount = failCount + 1

    # Create mask M of size alphan23 x clogn
    M = matrix(0, rows=alphan23, cols=clogn)
    for (i in 1:alphan23) { # todo: make parfor
        # Task: draw k '1's in a row vector of length log n
        s = sample(range=clogn, size=k, replacement=FALSE) # seed? maybe set new every loop? returns k x 1 col vector
        sOnes = matrix(1, rows=k, cols=1)                  # k x 1 col vector of 1s
        # construct a 1 x clogn row vector by filling the identified positions with 1s and the rest 0s
        sm = table(sOnes, s, 1, clogn)
        M[i,] = sm
    }

    # alphan23 x n
    G = -(M %*% A) %% 4 + (k%%2) + 1
    # alphan23 x n23
    B = G %*% S

    #(g1,g2) = maxIndex( t(B)%*%B - diag(diag(t(B)%*%B)) )
    X =  t(B)%*%B - diag(diag(t(B)%*%B))
    X_rowmax = rowMaxs(X) # col vector of max val in each row
    g1 = as.scalar(rowIndexMax(t(X_rowmax))) # row index of max val
    XR = X[g1,] # row vector
    g2 = as.scalar(rowIndexMax(XR)) # col index of max val

    #print("(g1,g2): " + g1 + ", " + g2)

    AG1 = A[, (g1-1)*n13+1 : g1*n13]
    AG2 = A[, (g2-1)*n13+1 : g2*n13]
    Y =  t(AG1)%*%AG2 - diag(diag(t(AG1)%*%AG2))

    Ymax = max(Y)
    OK = Ymax >= t
}

Y_rowmax = rowMaxs(Y) # col vector of max val in each row
Y_rowidx = as.scalar(rowIndexMax(t(Y_rowmax))) # row index of max val
YR = Y[Y_rowidx,] # row vector
Y_colidx = as.scalar(rowIndexMax(YR)) # col index of max val
# result: (Y_rowidx, Y_colidx)

i = as.matrix(Y_rowidx)
j = as.matrix(Y_colidx)
Z = cbind(i, j)

print("(i,j): " + Y_rowidx + ", " + Y_colidx)
print("failCount: "+failCount)
write(Z, $7);
