# Input matrix
A = read($A)    # clogn x n
clogn = nrow(A)
n = ncol(A)
print("A is "+clogn+" by "+n)

# Controls number of variables sampled per sample of the observations.
k = as.scalar(read($k))
# Controls number of samples of the observations.
alpha = as.scalar(read($alpha))
# Threshold for deciding whether we found a correlated variable.
t = round(as.scalar(read($t)))

# How many observations to use? Default all observations.
clogn = ifdef($clogn_reduce, clogn)
A = A[1:clogn,]

#c = as.scalar(read($3))
#c = round(c*10)/10
#n = as.scalar(read($2))

n13 = round(n^(1.0/3.0))
n23 = round(n^(2.0/3.0))
alphan23 = round(alpha*n^(2.0/3.0))
#logn = round(log(n,2))
#clogn = round(c*log(n,2))
print("clogn is "+clogn)
print("n is "+n)
print("k is "+k)
print("alpha is "+alpha)
print("t is "+t)
print("n13 is "+n13)
print("n23 is "+n23)
print("alphan23 is "+alphan23)
#print("logn is "+logn)
#n13 = as.scalar(read($8))
#n23 = as.scalar(read($9))
#alphan23 = as.scalar(read($10))
#logn = as.scalar(read($11))
#clogn = as.scalar(read($12))

# random matrix of -1 and 1
# todo optimize to 0 and 1
#AR = rand(rows=clogn, cols=n, min=0, max=1, pdf="uniform", sparsity=1.0)
#A = -1 * (AR <= 0.5) + (AR > 0.5)


# Create S of size n x n23
S = matrix(0, rows=n, cols=n23)
for (i in 1:n23) {
	S[(i-1)*n13+1:i*n13, i] = matrix(1, rows=n13, cols=1)
}

#time = externalFunction(Integer i) return (Double B)
#       implemented in (classname="org.apache.sysml.udf.lib.TimeWrapper", exectype="mem");
#ti = time(1)
#ti = as.integer(ti)
#print("Time: " + ti);

ok = FALSE
failCount = -1
Y = matrix(0, rows=n13, cols=n13)
sOnes = matrix(1, rows=k, cols=1)                  # k x 1 col vector of 1s
g1 = 0
g2 = 0
while (!ok) {
    failCount = failCount + 1

    # Create mask M of size alphan23 x clogn
    M = matrix(0, rows=alphan23, cols=clogn)
    for (i in 1:alphan23) { # todo: make parfor
        # Task: draw k '1's in a row vector of length log n
        #see = ti + i + failCount*alphan23 # attempt at setting random seed, but this must be a constant for the sample function
        s = sample(range=clogn, size=k, replacement=FALSE) # seed? maybe set new every loop? returns k x 1 col vector

        # The following code is an alternative to the sample function.
        # It generates k indices in [1,clogn] until all the indices are unique.
        #kvec = round(rand(rows=1, cols=k, min=1, max=clogn))
        #kvecOrd1 = order(target=t(kvec), by=1, decreasing=FALSE, index.return=FALSE)
        #kvecOrd = t(kvecOrd1)
        #kvecResid = kvecOrd[,2:k] - kvecOrd[,1:k-1]
        #while ( min(abs(kvecResid)) == 0 ) {
        #    kvec = round(rand(rows=1, cols=k, min=1, max=clogn))
        #    kvecOrd1 = order(target=t(kvec), by=1, decreasing=FALSE, index.return=FALSE)
        #    kvecOrd = t(kvecOrd1)
        #    kvecResid = kvecOrd[,2:k] - kvecOrd[,1:k-1]
        #}
        #s = t(kvec)


        # construct a 1 x clogn row vector by filling the identified positions with 1s and the rest 0s
        sm = table(sOnes, s, 1, clogn)
        M[i,] = sm
    }

    # alphan23 x n
    G = -( ((M %*% A) + 3*k) %% 4) +1
    # alphan23 x n23
    B = G %*% S

    #(g1,g2) = maxIndex( t(B)%*%B - diag(diag(t(B)%*%B)) )
    X =  t(B)%*%B - diag(diag(t(B)%*%B))
    X_rowmax = rowMaxs(X) # col vector of max val in each row
    g1 = as.scalar(rowIndexMax(t(X_rowmax))) # row index of max val
    XR = X[g1,] # row vector
    g2 = as.scalar(rowIndexMax(XR)) # col index of max val


    AG1 = A[, (g1-1)*n13+1 : g1*n13]
    AG2 = A[, (g2-1)*n13+1 : g2*n13]
    Y =  t(AG1)%*%AG2
    if (g1 == g2) {
        Y = Y - diag(diag(Y))
    }

    Ymax = max(Y)
    print("(g1,g2): " + g1 + ", " + g2 + " -- max "+Ymax)
    ok = Ymax >= t
}

Y_rowmax = rowMaxs(Y) # col vector of max val in each row
Y_rowidx = as.scalar(rowIndexMax(t(Y_rowmax))) # row index of max val
YR = Y[Y_rowidx,] # row vector
Y_colidx = as.scalar(rowIndexMax(YR)) # col index of max val

# add back to original group
i = round(Y_rowidx + (g1-1)*n13)
j = round(Y_colidx + (g2-1)*n13)

print("(Yi,Yj): " + Y_rowidx + ", " + Y_colidx)
print("(i,j)  : " + i + ", " + j)
i = as.matrix(i)
j = as.matrix(j)
Z = cbind(i, j)
print("failCount: "+failCount)
write(Z, $O);
