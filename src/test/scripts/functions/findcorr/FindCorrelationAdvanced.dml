
k = as.scalar(read($1))
n = as.scalar(read($2))
c = as.scalar(read($3))
alpha = as.scalar(read($4))
t = as.scalar(read($5))

#n13 = as.integer(n^(1.0/3.0)+0.000001)
#n23 = as.integer(n^(2.0/3.0)+0.000001)
#alphan23 = as.integer(alpha*n^(2.0/3.0)+0.000001)
#logn = as.integer(log(n,2))
#clogn = as.integer(c*log(n,2))
#print("n is "+n)
#print("n13 is "+n13)
#print("n23 is "+n23)
#print("alphan23 is "+alphan23)
#print("logn is "+logn)
#print("clogn is "+clogn)
n13 = as.scalar(read($8))
n23 = as.scalar(read($9))
alphan23 = as.scalar(read($10))
logn = as.scalar(read($11))
clogn = as.scalar(read($12))

# random matrix of -1 and 1
# todo optimize to 0 and 1
#AR = rand(rows=clogn, cols=n, min=0, max=1, pdf="uniform", sparsity=1.0)
#A = -1 * (AR <= 0.5) + (AR > 0.5)
A = read($6)    # clogn x n
Ar = nrow(A)
Ac = ncol(A)
print("A is "+Ar+" by "+Ac)

# Create S of size n x n23
S = matrix(0, rows=n, cols=n23)
for (i in 1:n23) {
	S[(i-1)*n13+1:i*n13, i] = matrix(1, rows=n13, cols=1)
}

ok = FALSE
failCount = -1
Y = matrix(0, rows=n13, cols=n13)
sOnes = matrix(1, rows=k, cols=1)                  # k x 1 col vector of 1s
while (!ok) {
    failCount = failCount + 1

    # Create mask M of size alphan23 x clogn
    M = matrix(0, rows=alphan23, cols=clogn)
    for (i in 1:alphan23) { # todo: make parfor
        # Task: draw k '1's in a row vector of length log n
        s = sample(range=clogn, size=k, replacement=FALSE) # seed? maybe set new every loop? returns k x 1 col vector

        # The following code is an alternative to the sample function.
        # It generates k indices in [1,clogn] until all the indices are unique.
        #kvec = round(rand(rows=1, cols=k, min=1, max=clogn))
        #kvecOrd1 = order(target=t(kvec), by=1, decreasing=FALSE, index.return=FALSE)
        #kvecOrd = t(kvecOrd1)
        #kvecResid = kvecOrd[,2:k] - kvecOrd[,1:k-1]
        #while ( min(abs(kvecResid)) == 0 ) {
        #    kvec = round(rand(rows=1, cols=k, min=1, max=clogn))
        #    kvecOrd1 = order(target=t(kvec), by=1, decreasing=FALSE, index.return=FALSE)
        #    kvecOrd = t(kvecOrd1)
        #    kvecResid = kvecOrd[,2:k] - kvecOrd[,1:k-1]
        #}
        #s = t(kvec)


        # construct a 1 x clogn row vector by filling the identified positions with 1s and the rest 0s
        sm = table(sOnes, s, 1, clogn)
        M[i,] = sm
    }

    # alphan23 x n
    G = -(M %*% A) %% 4 + (k%%2) + 1
    # alphan23 x n23
    B = G %*% S

    #(g1,g2) = maxIndex( t(B)%*%B - diag(diag(t(B)%*%B)) )
    X =  t(B)%*%B - diag(diag(t(B)%*%B))
    X_rowmax = rowMaxs(X) # col vector of max val in each row
    g1 = as.scalar(rowIndexMax(t(X_rowmax))) # row index of max val
    XR = X[g1,] # row vector
    g2 = as.scalar(rowIndexMax(XR)) # col index of max val

    print("(g1,g2): " + g1 + ", " + g2)

    AG1 = A[, (g1-1)*n13+1 : g1*n13]
    AG2 = A[, (g2-1)*n13+1 : g2*n13]
    Y =  t(AG1)%*%AG2 - diag(diag(t(AG1)%*%AG2))

    Ymax = max(Y)
    ok = Ymax >= t
}

Y_rowmax = rowMaxs(Y) # col vector of max val in each row
Y_rowidx = as.scalar(rowIndexMax(t(Y_rowmax))) # row index of max val
YR = Y[Y_rowidx,] # row vector
Y_colidx = as.scalar(rowIndexMax(YR)) # col index of max val

# add back to original group
i = Y_rowidx + (g1-1)*n13
j = Y_colidx + (g2-1)*n13

print("(Yi,Yj): " + Y_rowidx + ", " + Y_colidx)
print("(i,j)  : " + i + ", " + j)
i = as.matrix(i)
j = as.matrix(j)
Z = cbind(i, j)
print("failCount: "+failCount)
write(Z, $7);
